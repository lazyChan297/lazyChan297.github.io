(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{391:function(e,v,_){"use strict";_.r(v);var t=_(45),o=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),_("h2",{attrs:{id:"初始化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[e._v("#")]),e._v(" 初始化")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("_init()")]),e._v("函数：初始化生命周期函数，事件，渲染函数")]),e._v(" "),_("li",[e._v("调用"),_("code",[e._v("beforeCreate")]),e._v("钩子：初始化injection，state，provide\n"),_("ul",[_("li",[e._v("调用"),_("code",[e._v("created")]),e._v("钩子")])])]),e._v(" "),_("li",[e._v("执行"),_("code",[e._v("mountComponent")]),e._v("函数，创建updateComponent函数作为组件更新时调用，负责为组件创建观察者实例，然后返回当前组件实例\n如果没有定义"),_("code",[e._v("render")]),e._v("函数，会给当前实例的render赋值为一个创建空节点的函数"),_("code",[e._v("createEmptyVNode")]),e._v("，"),_("code",[e._v("createEmptyVNode")]),e._v("函数会创建一个空的"),_("code",[e._v("new VNode()")]),e._v("对象返回\n"),_("ul",[_("li",[e._v("执行"),_("code",[e._v("beforeMount")]),e._v("勾子函数")]),e._v(" "),_("li",[e._v("创建一个"),_("code",[e._v("updateComponent")]),e._v("函数\n"),_("ul",[_("li",[e._v("调用编译过程中生成的"),_("code",[e._v("vm._render()")]),e._v("函数（通过parse->optimize->generator返回的js字符串函数)执行，返回一个"),_("code",[e._v("VNode")]),e._v("对象")]),e._v(" "),_("li",[e._v("调用"),_("code",[e._v("vm._update(vnode)")]),e._v("其中涉及了patch、diff的流程")])])]),e._v(" "),_("li",[e._v("创建"),_("code",[e._v("new Watcher(vm, updateComponent)")]),e._v("实例，用当前组件(vue实例也就是vm)，和定义好的"),_("code",[e._v("updateComponent")]),e._v("函数。执行构造函数过程中会调用"),_("code",[e._v("updateComponent")]),e._v("方法，具体流程是组件求值的时候执行了"),_("code",[e._v("watch.get()")]),e._v(","),_("code",[e._v("watch.get()")]),e._v("内部调用了"),_("code",[e._v("updateComponent")]),e._v("，所以根据组件自身的render函数"),_("code",[e._v("vm._render()")]),e._v("得到新的vnode，再调用"),_("code",[e._v("vm._update()")]),e._v("函数，"),_("code",[e._v("vm._update()")]),e._v("函数内部会调用"),_("code",[e._v("vm.__patch__()")]),e._v("进入新旧节点对比，找到差异后通过document的api更改视图\n注意，如果在patch过程中遇到子节点，就会开始新一轮子节点初始化流程的生命周期，直到子节点初始化生命周期执行完毕，才会继续当前节点初始化的生命周期")])])])]),e._v(" "),_("h2",{attrs:{id:"更新流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#更新流程"}},[e._v("#")]),e._v(" 更新流程")]),e._v(" "),_("ol",[_("li",[e._v("响应式对象更新，set劫持被触发，当前响应式对象的dep派发更新")]),e._v(" "),_("li",[e._v("响应式对象的观察者的update方法被触发。因为vue使用了批量异步更新策略，所以会把组件自身添加到异步更新的队列中，通过nextTick控制需要更新的组件在异步任务队列中批量执行")]),e._v(" "),_("li",[e._v("当事件循环到异步任务执行，响应式对象的执行它的"),_("code",[e._v("updateComponent()")]),e._v("方法，该方法调用了"),_("code",[e._v("_vm.render()")]),e._v("，访问到了最新的响应式属性值，返回新的"),_("code",[e._v("VNode")]),e._v("对象。接着调用"),_("code",[e._v("vm._update(node)")]),e._v("方法，对比新旧虚拟dom的差异，最终通过差异定位要更新的视图内容，实现更新")])]),e._v(" "),_("h2",{attrs:{id:"组件销毁"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件销毁"}},[e._v("#")]),e._v(" 组件销毁")]),e._v(" "),_("ol",[_("li",[e._v("执行"),_("strong",[e._v("beforeDestroy")])]),e._v(" "),_("li",[e._v("如果组件存在parent则清除父子关系")]),e._v(" "),_("li",[e._v("移除组件的watcher和订阅者")]),e._v(" "),_("li",[e._v("执行"),_("strong",[e._v("destroyed")])])])])}),[],!1,null,null,null);v.default=o.exports}}]);