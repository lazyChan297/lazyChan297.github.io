(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{410:function(v,_,e){"use strict";e.r(_);var t=e(45),l=Object(t.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"数据类型转换机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据类型转换机制"}},[v._v("#")]),v._v(" 数据类型转换机制")]),v._v(" "),e("h2",{attrs:{id:"显式转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#显式转换"}},[v._v("#")]),v._v(" 显式转换")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Number()")]),v._v(" "),e("ul",[e("li",[v._v("原始类型\n"),e("ul",[e("li",[e("strong",[v._v("string")]),v._v(" 非空可以解析为相应的数字那么就是对应数字的值，如果其中有一个非数字那么就会转换为"),e("code",[v._v("NaN")]),v._v("，"),e("code",[v._v("let a = Number('1a') // NaN")]),v._v("，与parseInt不同 "),e("code",[v._v("let a = parsrInt('1a') // 1")]),v._v("，空字符串转换为0")]),v._v(" "),e("li",[e("strong",[v._v("boolean")]),v._v(" Number(true) => 1 Number(false) => 0")]),v._v(" "),e("li",[e("strong",[v._v("symbol")]),v._v(" 不能转换 会报错")])])]),v._v(" "),e("li",[v._v("引用类型 "),e("strong",[v._v("先调用自身类型的"),e("code",[v._v("valueOf")]),v._v("方法，如果获取的值不是原始类型，再调用自身类型的toString方法，接着按照字符串规则转换")]),v._v(" "),e("ul",[e("li",[e("strong",[v._v("对象")]),e("code",[v._v("Object.valueOf()")]),v._v(" 返回对象本身， "),e("code",[v._v("Object.toString()")]),v._v(" 返回 "),e("code",[v._v("[object 对象类型]")]),v._v(" "),e("ul",[e("li",[e("code",[v._v("Number({})")]),v._v("等于NaN，"),e("code",[v._v("{}.valueOf().toString() => '[object Object]'，Number('[object Object]') => NaN")])])])]),v._v(" "),e("li",[e("strong",[v._v("数组")]),e("code",[v._v("Array.valueOf()")]),v._v(" 返回数组本身，"),e("code",[v._v("Array.toString()")]),v._v("返回数组元素拼接的字符串用,分隔\n"),e("ul",[e("li",[e("code",[v._v("Number([1])")]),v._v("等于1， "),e("code",[v._v("[1].valueOf().toString() => '1'，Number('1') => 1")])]),v._v(" "),e("li",[e("code",[v._v("Number([1,2,3])")]),v._v("等于NaN，"),e("code",[v._v("[1,2,3].valueOf().toString() => '1,2,3'，Number('1,2,3') => NaN")])])])])])])])]),v._v(" "),e("li",[e("code",[v._v("String")]),v._v(" "),e("ul",[e("li",[v._v("原始类型\n"),e("ul",[e("li",[e("strong",[v._v("number")]),v._v(" 转换为数字字符串")]),v._v(" "),e("li",[e("strong",[v._v("boolean")]),v._v(' 转换为"true" 或者 "false"')]),v._v(" "),e("li",[e("strong",[v._v("undefined")]),v._v(' 转换为"undefined"')]),v._v(" "),e("li",[e("strong",[v._v("null")]),v._v(' 转换为"null"')])])]),v._v(" "),e("li",[v._v("引用类型  "),e("strong",[v._v("调用对象自身类型的"),e("code",[v._v("toString")]),v._v("方法，如果是原始类型则调用String函数，如果不是则调用该对象自身类型的valueOf方法，如果得到原始类型再调用String函数，如果toString和valueOf返回的仍然是引用类型就会报错")])])])]),v._v(" "),e("li",[e("code",[v._v("Boolean")]),v._v(" 只有这几种情况会转换为false "),e("code",[v._v("null")]),v._v("、"),e("code",[v._v("undefined")]),v._v("、 "),e("code",[v._v("0")]),v._v("、 "),e("code",[v._v("-0")]),v._v("、 "),e("code",[v._v("NaN")]),v._v("、 "),e("code",[v._v("''")]),v._v("，其它全部是true")])]),v._v(" "),e("h2",{attrs:{id:"隐式转换"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隐式转换"}},[v._v("#")]),v._v(" 隐式转换")]),v._v(" "),e("p",[v._v("隐式转换的规则与显式转换一致，区别在于不是用户主动调用的，而是在以下操作中自动触发")]),v._v(" "),e("ol",[e("li",[v._v("不同类型数据相加\n"),e("ul",[e("li",[v._v("如果+号的一边是字符串，那么另一边也会转换为字符串相加，"),e("code",[v._v("'1'+true => '1true'")])]),v._v(" "),e("li",[v._v("如果+号的一边是数字，那么另一边会自动转换为数字相加，"),e("code",[v._v("1 + true => 2")])]),v._v(" "),e("li",[v._v("如果+号的一边有引用类型，会对该引用类型调用自身的valueOf和toString，接着按照字符串相加的规则执行")])])]),v._v(" "),e("li",[v._v("对非数值类型使用一元运算符，会自动按照number()函数的转换规则执行")]),v._v(" "),e("li",[e("strong",[v._v("if语句")]),v._v("、"),e("strong",[v._v("否定运算符!")]),v._v("、"),e("strong",[v._v("三目运算符")]),v._v(" 会自动转换为boolean")]),v._v(" "),e("li",[v._v("比较运算符\n"),e("ul",[e("li",[v._v("原始类型，全部转换为数字比较\n"),e("ul",[e("li",[v._v("字符串与字符串，调用charCodeAt()比较")]),v._v(" "),e("li",[v._v("字符串或布尔值 与 数字比较，字符串或布尔值转换为数字在比较")])])]),v._v(" "),e("li",[v._v("引用类型\n"),e("ul",[e("li",[v._v("与字符串比较，先调用自身的valueOf和自身的toString，采用字符串规则比较\n"),e("ul",[e("li",[e("code",[v._v("['a'] < 'b'")]),v._v("等于true，"),e("code",[v._v("['a'].valueOf().toString().charCodeAt() => 97,'b'.charCodeAt() => 98")])])])]),v._v(" "),e("li",[v._v("与数字比较，先调用自身的valueOf和自身的toString，得到字符串后调用Number函数转换成数字比较")])])])])]),v._v(" "),e("li",[v._v("相等运算符"),e("code",[v._v("==")]),v._v("和不相等运算符"),e("code",[v._v("!=")]),v._v(" "),e("ul",[e("li",[v._v("字符串或布尔值与数字比较，都会自动转换为数字")]),v._v(" "),e("li",[v._v("引用类型与原始类型比较\n"),e("ul",[e("li",[v._v("与字符串比较，先调用自身的valueOf和toString得到原始值，"),e("code",[v._v("let a = {}; a == '[object Object] // true")])]),v._v(" "),e("li",[v._v("与数字比较，引用类型转换后的字符串再调用一次Number函数得到数字再进行比较\n"),e("ul",[e("li",[e("code",[v._v("[] == 0; //true, Number([].valueOf().toString()) => 0")])]),v._v(" "),e("li",[e("code",[v._v("![] == 0; //true, ![] => false, Number(false) => 0")])]),v._v(" "),e("li",[e("code",[v._v("[] == ![]; //true, Number([].valueOf().toString()) => 0, ![]=>false,Number(false) => 0")])])])])])]),v._v(" "),e("li",[v._v("引用类型与引用类型比较，不会触发类型转换，仅仅比较它们的引用对象是否是同一个")])])])])])}),[],!1,null,null,null);_.default=l.exports}}]);