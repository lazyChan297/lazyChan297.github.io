(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{428:function(t,e,n){"use strict";n.r(e);var v=n(45),r=Object(v.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"微前端架构浅谈"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#微前端架构浅谈"}},[t._v("#")]),t._v(" 微前端架构浅谈")]),t._v(" "),n("p",[t._v("和web微前端是相似的，有一个主应用和多个子应用。"),n("br"),t._v("\n主应用提供底层依赖和运行环境的能力。底层依赖例如路由导航控制子应用之间页面的跳转；数据储存，满足子应用之间的数据共享。"),n("br"),t._v("\n子应用提供业务能力，根据业务线的不同划分，将不同的rn交给不同的业务团队来开发，独立的git仓库维护。\n架构模式有一个主应用的rn项目，在它根目录下存放了多个子应用，子应用生成对应"),n("code",[t._v("rn")]),t._v("实例。通过切换不同的"),n("code",[t._v("rn")]),t._v("实例实现加载对应的子应用。")]),t._v(" "),n("p",[n("strong",[t._v("子应用之间的切换")]),t._v("实现思路以Android为例，创建一个多实例管理的类。因为"),n("code",[t._v("ReactNativeHost")]),t._v("提供了实例管理器"),n("code",[t._v("ReactIntanceManager")]),t._v("，通过实例管理器可以获取对应的实例和bundle文件，所以多实例管理类就通过传参的方式，生成不同的子应用实例和获取子应用实例。")]),t._v(" "),n("p",[n("strong",[t._v("路由机制")]),t._v("\n在原生端实现了一个"),n("code",[t._v("Router")]),t._v("类，该类实现了控制导航栈进出和保存导航栈信息的功能，"),n("br"),t._v("\nRouter类通过控制"),n("code",[t._v("ReactRootView")]),t._v("的挂载和卸载，实现页面进出路由栈")]),t._v(" "),n("p",[n("strong",[t._v("子应用之间的数据共享")]),t._v("通过封装"),n("code",[t._v("AsyncStorage")]),t._v(" （在原生提供的存储能力），"),n("br"),t._v("\n因为数据存储始终在原生端，仅仅是通过js方法来读取和修改，而对于子应用而言，它们的原生端始终是主应用里的原生端，"),n("br"),t._v("\n所以，即使子应用实例被销毁，数据也仍然存在，这样便可以在子应用中实现数据共享")])])}),[],!1,null,null,null);e.default=r.exports}}]);