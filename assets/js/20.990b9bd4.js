(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{374:function(v,_,t){"use strict";t.r(_);var s=t(45),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"tcp-udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp"}},[v._v("#")]),v._v(" TCP&UDP")]),v._v(" "),t("p",[v._v("两者都是作用于TCP/IP四层模型中的传输层协议")]),v._v(" "),t("h2",{attrs:{id:"tcp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),t("p",[v._v("传输控制协议，一种面向连接的、可靠的、基于字节流的传输层通信协议")]),v._v(" "),t("h3",{attrs:{id:"标志码说明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#标志码说明"}},[v._v("#")]),v._v(" 标志码说明")]),v._v(" "),t("ul",[t("li",[v._v("SYN: 发起连接报文，发起握手的那一方会携带这个标志码，如果是第一次"),t("code",[v._v("SYN=1")])]),v._v(" "),t("li",[v._v("ACK: 确认回应，回应发起握手那一方携带的标志位，如果是第一次，ACK=1")]),v._v(" "),t("li",[v._v("FIN: 断开链接报文")]),v._v(" "),t("li",[v._v("seq: 随机序列号")]),v._v(" "),t("li",[v._v("ack: 确认序列号，以对方传递的seq值为基准加1，是tcp数据可靠传输的基础")])]),v._v(" "),t("h3",{attrs:{id:"三次握手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程"}},[v._v("#")]),v._v(" 三次握手过程")]),v._v(" "),t("p",[v._v("建立连接前，tcp协议会发起三次握手，确认通信双方的接收能力\n"),t("strong",[v._v("第一次握手")])]),v._v(" "),t("ul",[t("li",[v._v("发送"),t("code",[v._v("SYN = 1")]),v._v("报文，表示第一次发起")]),v._v(" "),t("li",[v._v("发送初始化的序列号"),t("code",[v._v("seq")]),v._v(" 为了标识是客户端哪一个应用程序发起的")])]),v._v(" "),t("p",[t("strong",[v._v("第二次握手，服务端发起")]),t("br")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("SYN=1")]),v._v("表示服务端第一次发起，证明了服务端的发送能力")]),v._v(" "),t("li",[t("strong",[v._v("ACK=1")]),v._v("表示服务端第一次应答，证明了服务端的接受能力")]),v._v(" "),t("li",[t("strong",[v._v("ack=客户端初始化序列号+1")]),v._v("，为了确认客户端发送的SYN，把客户端发送的seq+1返回 （个人理解为这一标志为是确认对方的端口号，因为一台主机可以有多个客户端向服务器发起握手请求，ack是为确认来自哪个端口，表示服务端收到了客户端发起链接的某一个应用程序）")]),v._v(" "),t("li",[t("strong",[v._v("seq=服务端初始化序列号")]),v._v("，表示服务端的序列号，标识客户端某一个端口作出响应")])]),v._v(" "),t("p",[t("strong",[v._v("第三次握手，客户端发起")])]),v._v(" "),t("ul",[t("li",[t("code",[v._v("ACK = 1")]),v._v(" 客户端收到ACK=1知道了发起建立连接的服务器已经应答，所以客户端发送ACK，告知服务器它发来的建立联机已经确认，证明了客户端的接收能力")]),v._v(" "),t("li",[t("code",[v._v("ack = 服务端seq + 1")]),v._v(" 为了确认收到了服务端发来的SYN，把服务端seq+1返回")]),v._v(" "),t("li",[t("code",[v._v("seq = 客户端seq + 1")]),v._v(" 告知服务端，仍然是第一次发起握手请求的客户端发来的确认信息，因为是第二次发送，所以需要seq + 1")])]),v._v(" "),t("p",[t("strong",[v._v("只需要三次握手的原因")]),v._v(" 三次就可以确认双方的收发能力正常，所以三次足矣")]),v._v(" "),t("ul",[t("li",[v._v("第一次握手，确认了客户端发送能力")]),v._v(" "),t("li",[v._v("第二次握手，确认了服务端发送、接受能力")]),v._v(" "),t("li",[v._v("第三次握手，确认了客户端发送能力")])]),v._v(" "),t("h3",{attrs:{id:"四次挥手过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手过程"}},[v._v("#")]),v._v(" 四次挥手过程")]),v._v(" "),t("p",[v._v("断开连接前tcp链接会触发四次挥手\n"),t("strong",[v._v("第一次挥手，客户端发起")])]),v._v(" "),t("ul",[t("li",[v._v("发送"),t("code",[v._v("FIN = 1")]),v._v("，告知服务器断开链接")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("seq = x")]),v._v("，告知服务器是来自客户端的哪一个端口")])]),v._v(" "),t("p",[t("strong",[v._v("第二次挥手，服务端发起")])]),v._v(" "),t("ul",[t("li",[v._v("发送"),t("code",[v._v("ACK = 1")]),v._v("，告知客服端已经收到断开链接的请求")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("ack = 客户端seq + 1")]),v._v("，告知客户的确认来自哪一个客户端端口")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("seq = y")]),v._v("，告知客户端是服务器哪一个端口断开链接")])]),v._v(" "),t("p",[t("strong",[v._v("第三次挥手，服务器发起")])]),v._v(" "),t("ul",[t("li",[v._v("发送"),t("code",[v._v("FIN = 1")]),v._v("，告知客户端内容全部发送完成，发起断开链接的请求")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("ack = 客户端seq + 1")]),v._v("，个人理解，再一次发送"),t("code",[v._v("ack")]),v._v("目的是让客户端确认还是刚刚服务器发送的确认断开连接")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("seq = j")]),v._v("，告知客户端是服务器哪一个端口断开链接")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("ACK = 1")]),v._v("，告知客服端已经收到断开链接的请求")])]),v._v(" "),t("p",[t("strong",[v._v("第四次挥手，客户端发起")])]),v._v(" "),t("ul",[t("li",[v._v("发送"),t("code",[v._v("ACK = 1")]),v._v("，告知服务器已经收到断开链接的请求")]),v._v(" "),t("li",[v._v("发送"),t("code",[v._v("seq = 客户端seq + 1")]),v._v("，告知服务器仍然是第一次发起断开链接的客户端端口\b应答，确认收到了断开链接的请求")]),v._v(" "),t("li",[t("code",[v._v("ack = 服务器seq + 1")]),v._v("，告知服务器，已经收到断开连接的请求了，可以断开了")])]),v._v(" "),t("p",[t("strong",[v._v("需要四次挥手的原因")]),v._v("\n因为当服务器收到客户端的"),t("code",[v._v("FIN")]),v._v("报文时，服务器很可能还有内容没有传输完毕，"),t("br"),v._v("\n所以需要等服务器再一次发次"),t("code",[v._v("FIN")]),v._v("（第三次挥手），"),t("br"),v._v("\n客户端的应答（第四次）。"),t("br"),v._v("\n本质上和三次握手确认双方的收发能力正常外，还需要一次是确认双方都发送了"),t("code",[v._v("FIN")])]),v._v(" "),t("h3",{attrs:{id:"重传机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重传机制"}},[v._v("#")]),v._v(" 重传机制")]),v._v(" "),t("p",[v._v("为了保证TCP传输的数据都可以到达")]),v._v(" "),t("h4",{attrs:{id:"超时重传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#超时重传"}},[v._v("#")]),v._v(" 超时重传")]),v._v(" "),t("p",[v._v("发送方发送seq时会开启一个定时器，如果超时没有收到对应的"),t("code",[v._v("ack")]),v._v("，那么会启用超时重传，也可能会把后续的数据包一起重传。但是这样会使等待的时间过长，也可能会造成带宽的浪费")]),v._v(" "),t("h4",{attrs:{id:"快速重传"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速重传"}},[v._v("#")]),v._v(" 快速重传")]),v._v(" "),t("p",[v._v("假如发送方连续发送5个数据包给接收方，数据包2因为某些原因延迟，但是3、4、5陆续到达了。所以接收方发送了三个ack=2的确认应答给发送方。发送方则根据ack得知是数据包2超时，所以启用快速重传。假如数据包出现连续的延迟或丢失，接收方发送了ack=2，ack=9，ack=15，那么此时可能会把2-15的数据包一起重传")]),v._v(" "),t("h4",{attrs:{id:"sack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#sack"}},[v._v("#")]),v._v(" SACK")]),v._v(" "),t("p",[v._v("为了解决重复数据的问题，接受方在原有的ack基础上增加了SACK，表示本次实际接收到的seq，这样发送方就可以精准的知道是哪个包丢失了")]),v._v(" "),t("h3",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[v._v("#")]),v._v(" 滑动窗口")]),v._v(" "),t("p",[v._v("作用是为了防止网络拥堵导致数据丢包，也是tcp保证数据可靠传输的支撑之一"),t("br"),v._v("\n接收方每次应答的时候会携带"),t("code",[v._v("Advertised-Window")]),v._v("的值，告知发送方自己还剩余多少缓存区可用；发送方接收到该值后会调整数据包的大小再发送")]),v._v(" "),t("h4",{attrs:{id:"zero-window"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zero-window"}},[v._v("#")]),v._v(" zero window")]),v._v(" "),t("p",[v._v("发送方每次发送的"),t("code",[v._v("Advertised-Window")]),v._v("值都是递减的，当发送端接收到的值变为0的时候，发送方会把ZeroWindowProbe的包发给接收方，让接收方应答它可用的window大小，一般这个值会设置三次，每次等待"),t("code",[v._v("30-60")]),v._v("s，如果三次过后仍然为0，那么连接很可能会断开")]),v._v(" "),t("h4",{attrs:{id:"silly-window"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#silly-window"}},[v._v("#")]),v._v(" silly window")]),v._v(" "),t("ul",[t("li",[v._v("接收方造成拥堵时，会应答ack=0给发送方，关闭接受的窗口，直到window size大于mss=578(每一个ip设备至少接受的size)时才会重新打开窗口")]),v._v(" "),t("li",[v._v("发送方造成拥堵时\n"),t("ol",[t("li",[v._v("当window size >= mss 或者 要发送的数据>= mss 时")]),v._v(" "),t("li",[v._v("当收到接受方的ack回执")])])])]),v._v(" "),t("h3",{attrs:{id:"拥塞处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞处理"}},[v._v("#")]),v._v(" 拥塞处理")]),v._v(" "),t("p",[v._v("TCP协议拥有以下一系列的拥塞控制机制，防止网络拥堵导致数据丢包")]),v._v(" "),t("h4",{attrs:{id:"慢启动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#慢启动"}},[v._v("#")]),v._v(" 慢启动")]),v._v(" "),t("p",[v._v("最初的TCP在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免拥塞现象的发生。\n"),t("strong",[v._v("当新建连接时，cwnd初始化为1个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd就增加1个MSS大小。")])]),v._v(" "),t("h4",{attrs:{id:"拥塞避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞避免"}},[v._v("#")]),v._v(" 拥塞避免")]),v._v(" "),t("p",[v._v("当拥塞窗口"),t("code",[v._v("cwnd")]),v._v("的值达到慢启动门限阈值（ssthresh）时，就会进入拥塞避免状态，此时"),t("code",[v._v("cwnd")]),v._v("不再是指数级增加，而是加法增加，这样可以防止发送的数据包过大而超出接收方的接收范围"),t("br"),v._v("\n当发生快速重传的时候，TCP也会作出以下操作，判定网络进入拥塞避免状态，同时作出以下调整")]),v._v(" "),t("ul",[t("li",[v._v("慢启动门限阈值（ssthresh）降低为拥塞窗口（cwnd）的一半")]),v._v(" "),t("li",[v._v("拥塞窗口（cwnd）设置为慢启动门限阈值（ssthresh）")]),v._v(" "),t("li",[v._v("进入拥塞避免状态")])]),v._v(" "),t("h4",{attrs:{id:"拥塞状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞状态"}},[v._v("#")]),v._v(" 拥塞状态")]),v._v(" "),t("p",[v._v("当出现超时重传，TCP认为网络进入了"),t("code",[v._v("拥塞状态")]),v._v("，TCP就会作出以下调整")]),v._v(" "),t("ul",[t("li",[v._v("将慢启动门限阈值（ssthresh）降低为拥塞窗口（cwnd）的一半")]),v._v(" "),t("li",[v._v("将拥塞窗口（cwnd）重新设置为1")]),v._v(" "),t("li",[v._v("此时网络就会重新进入慢启动状态")])]),v._v(" "),t("h4",{attrs:{id:"快速恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速恢复"}},[v._v("#")]),v._v(" 快速恢复")]),v._v(" "),t("p",[v._v("当之前丢失的包都收到ack应答时，证明丢失的数据包接收方都已经收到，此时启用快速恢复机制，使网络进入拥塞避免状态")]),v._v(" "),t("h2",{attrs:{id:"udp"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#udp"}},[v._v("#")]),v._v(" UDP")]),v._v(" "),t("p",[v._v("用户数据包协议，是一个简单的「面向数据报的通信协议」，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层")]),v._v(" "),t("h2",{attrs:{id:"tcp-udp之间的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp-udp之间的区别"}},[v._v("#")]),v._v(" TCP/UDP之间的区别")]),v._v(" "),t("ul",[t("li",[v._v("TCP是面向连接的，建立连接前发起三次握手，断开连接前发起四次挥手，通过握手和挥手的过程中通过SYN报文，FIN报文和序列号确认了双方是自己的通信目标，而UDP是面向无连接的。")]),v._v(" "),t("li",[v._v("TCP连接传输的数据更可靠，可靠体现在避免数据丢失、超时、重复，保证数据按序到达，以上措施是序列号和确认应答码机制来实现的。\n"),t("ul",[t("li",[v._v("数据丢失或延迟，发送方发送seq时会开启一个定时器，如果在指定时间内没有接收到ACK（seq + 1），那么会把数据和seq再发送一次")])])]),v._v(" "),t("li",[v._v("UDP传输效率比TCP快")]),v._v(" "),t("li",[v._v("TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用")]),v._v(" "),t("li",[v._v("TCP支持全双工通信（双向同时通信），UDP支持1对1，一对多，多对多，多对一")]),v._v(" "),t("li",[v._v("TCP 应用场景适用于对效率要求低，对准确性要求高或者要求有链接的场景，而UDP 适用场景为对效率要求高，对准确性要求低的场景")])]),v._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("ol",[t("li",[t("a",{attrs:{href:"https://coolshell.cn/articles/11564.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("TCP 的那些事儿（上）"),t("OutboundLink")],1)]),v._v(" "),t("li",[t("a",{attrs:{href:"https://coolshell.cn/articles/11609.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("TCP 的那些事儿（下）"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=a.exports}}]);